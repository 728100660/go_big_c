"""
整数编码
题目描述
实现一个整数编码方法，使得待编码的数字越小，编码后所占用的字节数越小。
编码规则如下：
1.编码时7位一组，每个字节的低7位用于存储待编码数字的补码
2.字节的最高位表示后续是否还有字节，置1表示后面还有更多的字节，
置0表示当前字节为最后一个字节
3.采用小端序编码，低位和低字节放在低地址上
4.编码结果按16进制数的字符格式进行输出，小写字母需要转化为大写字母。

输入描述
输入的为一个字符串表示的非负整数。

输出描述
输出一个字符串表示整数编码的16进制码流。
2:  0000 0010     反码: 0000 0010
-2: 1000 0010     反码: 1111 1101     补码：1111 1110
1111 1110        反码: 1000 0000      补码: 1000 0001
示例1
输入

0

输出

00

说明：输出的16进制字符不足两位的前面补零。

示例2
输入

100

输出

64

说明：100的二进制表示为0110 0100只需一个字节进行编码。字节的最高位0，剩余7位存储数字100的低7位(1100100)所以编码后的输出为64。

示例3
输入

1000

输出

E807

说明：1000的二进制表示为 0011 1110 1000 至少需要两个字节进行编码，第一个字节最高位是1 剩余7位存储数字 1000的低7位(1101000)，所以第一个字节的二进制位(1110 1000)即E8，第二个字节最高位置0 剩余的7位存储数字 1000的第二个低7位(0000111)，所以第一个字节的二进制为(0000 0111)即07，采用小端序编码 所以低字节E8输出在前面，高字节07输出在后面。

备注
    代编码数字取值范围为 [0,1<<64-1]。
"""

"""
思路：好像也没啥思路
补充知识点：补码
正数的补码就是原码
负数的补码=反码+1
负数的反码=原码除了符号位取反
"""
num = int(input())
# 将num转换成二进制字符串，num>0
b_num_list = []      # 从低位bit往高位存储
if num == 0:
    b_num_list = [0]
while num != 0:
    b_num_list.append(num%2)
    num = num // 2
tmp_list = []   # 低字节往高字节存储
one_byte_val = 0    # 单个字节的编码值
for idx, val in enumerate(b_num_list):      # 从低位bit往高位遍历
    if idx % 7 == 0 and idx != 0:
        tmp_list = []
        if idx+1 < len(b_num_list):    # 后面还有bit位, 第八位置为1
            one_byte_val += 2**7
        tmp_list.append(one_byte_val)
        one_byte_val = 0
        continue
    one_byte_val += val * 2**(idx%7)
    if idx+1 >= len(b_num_list):    # 后面没有bit位，直接添加进列表
        tmp_list.append(one_byte_val)

hex_map = {10: "A", 11: "B", 12: "C", 13: "D", 14: "E", 15: "F"}
# 将列表转换为 16进制输出
hex_list = []
for num in tmp_list:
    tmp_hex_list = []   # 低位到高位
    while num != 0:
        tmp_hex_list.append(hex_map.get(num % 16, str(num % 16)))
        num = num // 16
    hex_list.append("".join(tmp_hex_list[::-1]).rjust(2, "0"))  # 实际上输出需要高位到低位
print("".join(hex_list))