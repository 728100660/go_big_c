"""
阿里巴巴找黄金宝箱5
题目内容
贫如洗的樵夫阿里巴巴在去砍柴的路上，无意中发现了强盗集团的藏宝地，藏宝地有编号从
0~N的箱子，每个箱子上面贴有一个数字。

阿里巴巴念出一个咒语数字
k(k<N)，找出连续
k个宝箱数字和的最大值，并输出该最大值。

输入描述
第一行输入一个数字字串，数字之间使用逗号分隔，例如:
2,10,−3,−8,40,5

1≤字串中数字的个数≤100000
−10000≤每个数字≤10000
第二行输入咒语数字，例如:
4，咒语数字大小小于宝箱的个数

输出描述
连续
k个宝箱数字和的最大值，例如:
39

样例
输入

2,10,-3,-8,40,5
4
输出

39
说明

无

输入

8
1
输出

8
说明

无
"""

"""
思路：模拟 --- 会超时
在求和的时候可以优化为o1， 只需要减去左端加上右端即可，没必要从头到尾都算一遍和
"""

def main():
    boxs = list(map(int, input().split(',')))
    k_nums = int(input())       # 连续宝箱个数    个数小于等于box长度

    tmp_sum = sum(boxs[0:k_nums])    # 初始化前k个宝箱之和
    max_val = tmp_sum
    for idx in range(k_nums, len(boxs)):
        # 宝箱之和往右移动
        tmp_sum -= boxs[idx - k_nums]   # 减左边
        tmp_sum += boxs[idx]        # 加右边
        max_val = max(tmp_sum, max_val)  # 结尾正常来说取不到，所以要+1
    return max_val

print(main())